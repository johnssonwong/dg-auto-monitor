name: DG Monitor 24x7 (Precision Final)

on:
  schedule:
    - cron: "*/5 * * * *"   # 每5分钟运行一次
  workflow_dispatch:

permissions:
  contents: write

jobs:
  run:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install playwright==1.46.0 opencv-python-headless numpy pillow requests pytz
          python -m playwright install --with-deps chromium

      - name: Write monitor.py (precision detection)
        shell: bash
        run: |
          cat > monitor.py << 'PY'
          # -*- coding: utf-8 -*-
          import os, time, json, traceback, statistics, math
          from datetime import datetime
          import pytz
          import requests
          import numpy as np
          import cv2
          from playwright.sync_api import sync_playwright

          # ============ 固定参数（已写入你的凭据；如设置了 Secrets 会优先生效） ============
          TG_TOKEN = os.getenv("TG_TOKEN") or "8134230045:AAH6C_H53R_J2RH98fGTqZFHsjkKALhsTh8"
          TG_CHAT_ID = os.getenv("TG_CHAT_ID") or "485427847"
          DG_URLS = ["https://dg18.co/wap/", "https://dg18.co/"]
          TZ = pytz.timezone("Asia/Kuala_Lumpur")
          STATE_FILE = "state.json"
          DEBUG_ANNOTATE = False   # 如需调试可改 True：会在日志中保存标注图（不发图给TG，避免打扰）

          # ============ 工具函数 ============
          def now_ts_ms():
              return int(datetime.now(TZ).timestamp() * 1000)

          def send_tg(text: str):
              try:
                  requests.post(
                      f"https://api.telegram.org/bot{TG_TOKEN}/sendMessage",
                      data={"chat_id": TG_CHAT_ID, "text": text, "parse_mode": "HTML"},
                      timeout=20,
                  )
              except Exception:
                  pass

          def send_tg_photo(img_path: str, caption: str = ""):
              try:
                  with open(img_path, "rb") as f:
                      requests.post(
                          f"https://api.telegram.org/bot{TG_TOKEN}/sendPhoto",
                          data={"chat_id": TG_CHAT_ID, "caption": caption},
                          files={"photo": f},
                          timeout=30,
                      )
              except Exception:
                  pass

          def load_state():
              if os.path.exists(STATE_FILE):
                  try:
                      return json.load(open(STATE_FILE, "r", encoding="utf-8"))
                  except Exception:
                      return {}
              return {}

          def save_state(st):
              with open(STATE_FILE, "w", encoding="utf-8") as f:
                  json.dump(st, f, ensure_ascii=False, indent=2)

          # ============ 图像处理：提取红/蓝圆点 ============
          def bgr_from_bytes(b: bytes):
              arr = np.frombuffer(b, np.uint8)
              return cv2.imdecode(arr, cv2.IMREAD_COLOR)

          def detect_colored_circles(bgr):
              """双通道：HSV 阈值 + 霍夫圆，再用轮廓兜底。返回 red_pts/blue_pts 列表[(x,y),...]"""
              hsv = cv2.cvtColor(bgr, cv2.COLOR_BGR2HSV)

              # 红色范围（两段）
              lower_red1 = np.array([0, 70, 70]);   upper_red1 = np.array([10, 255, 255])
              lower_red2 = np.array([160, 70, 70]); upper_red2 = np.array([180, 255, 255])
              mask_r = cv2.bitwise_or(cv2.inRange(hsv, lower_red1, upper_red1),
                                      cv2.inRange(hsv, lower_red2, upper_red2))
              # 蓝色范围
              lower_blue = np.array([90, 50, 50]);  upper_blue = np.array([140, 255, 255])
              mask_b = cv2.inRange(hsv, lower_blue, upper_blue)

              def hough_and_contour(mask):
                  mask = cv2.medianBlur(mask, 5)
                  # 自适应半径范围（按图大小）
                  h, w = mask.shape[:2]
                  minR = max(3, int(min(h, w) * 0.008))
                  maxR = max(minR+2, int(min(h, w) * 0.03))
                  # 霍夫圆
                  circles = cv2.HoughCircles(mask, cv2.HOUGH_GRADIENT, dp=1.2, minDist=max(6, minR*2),
                                             param1=80, param2=12, minRadius=minR, maxRadius=maxR)
                  pts = []
                  if circles is not None:
                      for c in np.uint16(np.around(circles[0, :])):
                          pts.append((int(c[0]), int(c[1])))
                  # 轮廓兜底
                  cnts, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
                  for cnt in cnts:
                      (x, y), r = cv2.minEnclosingCircle(cnt)
                      area = cv2.contourArea(cnt)
                      if area <= 0: continue
                      circ = (4*math.pi*area) / (cv2.arcLength(cnt, True)**2 + 1e-6)
                      if 0.3 < circ <= 1.2 and minR*minR*math.pi*0.4 <= area <= maxR*maxR*math.pi*1.8:
                          pts.append((int(x), int(y)))
                  # 去重
                  uniq = []
                  for p in pts:
                      if all((abs(p[0]-q[0])>4 or abs(p[1]-q[1])>4) for q in uniq):
                          uniq.append(p)
                  return uniq

              red_pts  = hough_and_contour(mask_r)
              blue_pts = hough_and_contour(mask_b)
              return red_pts, blue_pts

          # ============ 列聚类 & 连续统计 ============
          def cluster_columns(points, x_tol=None):
              if not points: return []
              pts = sorted(points, key=lambda p: p[0])
              xs = [p[0] for p in pts]
              diffs = [xs[i+1]-xs[i] for i in range(len(xs)-1)] if len(xs)>1 else [16]
              cell_w = max(8, int(statistics.median(diffs)))  # 估计每列间距
              tol = x_tol or max(8, int(cell_w*0.6))
              cols = [[pts[0]]]
              for p in pts[1:]:
                  if abs(p[0]-cols[-1][-1][0]) <= tol:
                      cols[-1].append(p)
                  else:
                      cols.append([p])
              for c in cols:
                  c.sort(key=lambda p: p[1])  # 按 y 从上到下
              return cols

          def longest_run_in_col(col_pts):
              """估算同列最大‘从上到下’可数的粒数，忽略极小 y 间距的重叠点"""
              if not col_pts: return 0
              ys = [p[1] for p in col_pts]
              runs = 1; best = 1
              # 自适应最小步进（过滤重叠画笔）
              gaps = [ys[i+1]-ys[i] for i in range(len(ys)-1)]
              step = max(5, int(statistics.median(gaps)) if gaps else 10)
              for i in range(1, len(ys)):
                  if ys[i] - ys[i-1] >= step:
                      runs += 1
                      best = max(best, runs)
              return best

          def has_duolian_adjacent(color_cols):
              """相邻两列同色 & 两列各自最长≥4  => ‘多连/连珠’"""
              if len(color_cols) < 2: return False
              # 按 x 排序
              cols_sorted = sorted(color_cols, key=lambda col: sum(p[0] for p in col)/len(col))
              for i in range(len(cols_sorted)-1):
                  if longest_run_in_col(cols_sorted[i]) >= 4 and longest_run_in_col(cols_sorted[i+1]) >= 4:
                      return True
              return False

          def analyze_table(bgr, idx=0):
              """对单张桌面图像（canvas或整页截屏）做统计"""
              red_pts, blue_pts = detect_colored_circles(bgr)
              marker_count = len(red_pts)+len(blue_pts)
              # 没点或点太少的图，视为非桌面/无效
              if marker_count < 15:
                  return None

              red_cols  = cluster_columns(red_pts)
              blue_cols = cluster_columns(blue_pts)
              all_cols  = cluster_columns(red_pts+blue_pts)

              # 各类判断
              long4_R = [c for c in red_cols  if longest_run_in_col(c) >= 4]
              long4_B = [c for c in blue_cols if longest_run_in_col(c) >= 4]

              long8_R  = any(longest_run_in_col(c) >= 8  for c in red_cols)
              long8_B  = any(longest_run_in_col(c) >= 8  for c in blue_cols)
              long10_R = any(longest_run_in_col(c) >= 10 for c in red_cols)
              long10_B = any(longest_run_in_col(c) >= 10 for c in blue_cols)

              has_long4  = (len(long4_R)+len(long4_B)) > 0
              has_long8  = (long8_R or long8_B)
              has_long10 = (long10_R or long10_B)
              has_duo    = has_duolian_adjacent(red_cols) or has_duolian_adjacent(blue_cols)

              # 单跳比例：把所有列的最长连数<=1 视为单跳列
              if all_cols:
                  single_cols = sum(1 for c in all_cols if longest_run_in_col(c) <= 1)
                  single_ratio = single_cols/len(all_cols)
              else:
                  single_ratio = 1.0

              # 调试标注（可选）
              if DEBUG_ANNOTATE:
                  dbg = bgr.copy()
                  for x,y in red_pts:  cv2.circle(dbg,(x,y),6,(0,0,255),2)
                  for x,y in blue_pts: cv2.circle(dbg,(x,y),6,(255,0,0),2)
                  cv2.putText(dbg,f"L4:{has_long4} L8:{has_long8} L10:{has_long10} Duo:{has_duo}",(10,26),
                              cv2.FONT_HERSHEY_SIMPLEX,0.7,(0,255,0),2)
                  cv2.imwrite(f"annot_table_{idx}.png", dbg)

              return {
                  "has_long4": has_long4,
                  "has_long8": has_long8,
                  "has_long10": has_long10,
                  "has_duolian": has_duo,
                  "single_ratio": float(single_ratio),
                  "marker_count": int(marker_count),
              }

          # ============ 浏览器：进入 DG 并抓取画面 ============
          def try_enter_and_capture():
              imgs = []
              with sync_playwright() as p:
                  browser = p.chromium.launch(headless=True, args=[
                      "--disable-blink-features=AutomationControlled",
                      "--no-sandbox",
                      "--disable-gpu"
                  ])
                  ctx = browser.new_context(viewport={"width": 1280, "height": 2600})
                  page = ctx.new_page()
                  try:
                      for url in DG_URLS:
                          try:
                              page.goto(url, timeout=30000)
                              # 点击“免费试玩 / Free”
                              clicked = False
                              for sel in ["text=免费试玩", "text=Free", "button:has-text('免费试玩')", "a:has-text('免费试玩')", "text=FREE", "text=free"]:
                                  try:
                                      page.click(sel, timeout=2500)
                                      clicked = True
                                      break
                                  except Exception:
                                      continue
                              # 可能新开页
                              time.sleep(1.0)
                              if len(ctx.pages) > 1:
                                  page = ctx.pages[-1]

                              # 等待页面资源加载 & 滚动加载
                              page.wait_for_load_state("networkidle", timeout=20000)
                              for _ in range(6):
                                  page.mouse.wheel(0, 600); time.sleep(0.25)

                              # 尝试抓取 canvas（大多数路单在 canvas）
                              canvases = page.query_selector_all("canvas")
                              for i, c in enumerate(canvases):
                                  try:
                                      box = c.bounding_box()
                                      if not box: continue
                                      if 90 <= box["width"] <= 1000 and 60 <= box["height"] <= 700:
                                          imgs.append(c.screenshot())
                                  except Exception:
                                      continue

                              # 兜底：整页截图（用于某些终端布局）
                              if not imgs:
                                  imgs.append(page.screenshot(full_page=True))

                              if imgs:
                                  break
                          except Exception:
                              continue
                  finally:
                      browser.close()
              return imgs

          # ============ 局势分类（严格按你给的阈值） ============
          def classify_all(stats):
              # 过滤无效桌（标记点太少的）
              stats = [s for s in stats if s and s["marker_count"] >= 15]
              n = len(stats)
              if n == 0:
                  return "NO_DATA", {"tables": 0}

              long4_tables  = sum(1 for s in stats if s["has_long4"] and s["single_ratio"] < 0.7)
              long8_tables  = sum(1 for s in stats if s["has_long8"])
              long10_tables = sum(1 for s in stats if s["has_long10"])
              duolian_tables= sum(1 for s in stats if s["has_duolian"])
              single_heavy  = sum(1 for s in stats if s["single_ratio"] >= 0.7)

              # 规则：超长龙 + 至少两张长龙（总≥3张）也算放水
              trigger_super = (long10_tables >= 1 and (long8_tables + long10_tables) >= 3)

              # 放水时段（提高胜率）
              cond_full = (n >= 20 and long4_tables >= 8) or (10 <= n < 20 and long4_tables >= 4) or trigger_super

              # 中等胜率（中上）
              cond_mid_up = False
              if ((n >= 20 and long4_tables >= 6) or (10 <= n < 20 and long4_tables >= 3)) \
                 and ((long8_tables + long10_tables) >= 2) and (duolian_tables >= 1):
                  cond_mid_up = True

              # 收割（不提醒）：长龙<2 且 单跳泛滥
              cond_harvest = (long8_tables + long10_tables) < 2 and single_heavy >= max(3, int(0.5*n))

              detail = {
                  "tables": n,
                  "long4_tables": long4_tables,
                  "long8_tables": long8_tables,
                  "long10_tables": long10_tables,
                  "duolian_tables": duolian_tables,
                  "single_heavy": single_heavy,
                  "trigger_super": trigger_super,
              }

              if cond_full:   return "FANGSHUI", detail
              if cond_mid_up: return "MID_UP", detail
              if cond_harvest:return "HARVEST", detail
              return "MID", detail

          # ============ 运行主流程 ============
          def main():
              st = load_state()
              try:
                  raw_imgs = try_enter_and_capture()
                  if not raw_imgs:
                      send_tg("⚠️ 检测失败：未截到桌面画面（可能需滑块或页面结构变化）。")
                      return

                  stats = []
                  for i, b in enumerate(raw_imgs):
                      bgr = bgr_from_bytes(b)
                      s = analyze_table(bgr, idx=i)
                      if s: stats.append(s)

                  status, d = classify_all(stats)
                  now_str = datetime.now(TZ).strftime("%Y-%m-%d %H:%M")
                  if status == "NO_DATA":
                      send_tg(f"{now_str}（马来西亚时间）\n⚠️ 未获取有效桌面数据，请稍后再试。")
                      return

                  # 组装简报
                  brief = (
                      f"桌数:{d['tables']} | 长连≥4:{d.get('long4_tables',0)} | "
                      f"长龙≥8:{d.get('long8_tables',0)} | 超长龙≥10:{d.get('long10_tables',0)} | "
                      f"多连/连珠:{d.get('duolian_tables',0)}"
                  )

                  last_status = st.get("status")
                  active_since = st.get("active_since")

                  # 放水与中上：提醒
                  if status in ("FANGSHUI","MID_UP"):
                      if last_status not in ("FANGSHUI","MID_UP"):
                          st["active_since"] = now_ts_ms()
                          st["active_type"] = status
                          send_tg(
                              f"{now_str}（马来西亚时间）\n"
                              f"✅ {'放水时段（提高胜率）' if status=='FANGSHUI' else '中等胜率（中上）'} 已开始\n{brief}"
                          )
                      else:
                          # 正处于放水/中上，不重复刷屏
                          pass
                  else:
                      # 非放水态
                      if last_status in ("FANGSHUI","MID_UP") and active_since:
                          dur_min = max(1, int((now_ts_ms()-active_since)/60000))
                          send_tg(
                              f"{now_str}（马来西亚时间）\n"
                              f"🔔 放水已结束，共持续 {dur_min} 分钟。\n{brief}"
                          )
                          st["active_since"] = None
                          st["active_type"] = None
                      else:
                          # 心跳
                          send_tg(f"{now_str}（马来西亚时间）\nℹ️ 检测完成：目前无放水迹象。\n{brief}")

                  st["status"] = status
                  save_state(st)

              except Exception as e:
                  err = f"{e}\n{traceback.format_exc()}"
                  open("last_error.txt","w",encoding="utf-8").write(err)
                  send_tg(f"⚠️ 脚本异常：{str(e)[:700]}")

          if __name__ == "__main__":
              main()
          PY

      - name: Run monitor
        env:
          TG_TOKEN: ${{ secrets.TG_TOKEN }}
          TG_CHAT_ID: ${{ secrets.TG_CHAT_ID }}
        run: |
          python monitor.py

      - name: Persist state (store status & history)
        run: |
          if [ -n "$(git status --porcelain)" ]; then
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add -A
            git commit -m "update state [skip ci]"
            git push
          fi
