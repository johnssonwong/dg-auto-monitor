name: DG Monitor - Final (5min)

on:
  schedule:
    - cron: "*/5 * * * *"   # 每 5 分钟运行一次
  workflow_dispatch:         # 可手动触发

permissions:
  contents: write

jobs:
  dg-monitor:
    runs-on: ubuntu-latest
    timeout-minutes: 14

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python 3.11
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies (Playwright + CV)
        run: |
          python -m pip install --upgrade pip
          pip install --no-cache-dir playwright==1.46.0 opencv-python-headless numpy pillow requests pytz
          # install playwright browser binaries
          python -m playwright install --with-deps chromium

      - name: Write monitor.py (final detection script)
        run: |
          cat > monitor.py <<'PY'
#!/usr/bin/env python3
# -*- coding: utf-8 -*-


DG 自动检测最终版（按用户所有规则）
- 每次运行会：
  1) 进入 https://dg18.co/wap/ 或 https://dg18.co/ -> 点击 Free/免费试玩 -> 尝试解决滑块
  2) 抓取屏幕内所有 canvas 截图（或可用的走势区域截图）
  3) 以颜色 + 圆检测识别红/蓝线圈，聚类为列，按列计算“同排连续”长度（用于长连/长龙/超长龙、多连/连珠判断）
  4) 根据你定义的规则判断四种时段：放水 (FANGSHUI)、中等胜率(中上 MID_UP)、胜率中等(MID)、收割(HARVEST)
  5) 发送 Telegram 通知（开始/心跳/结束/错误），同时估算持续时长（基于历史趋势）
- 设计目标：稳定、云端、无须本地运行、无需截图上传、完全按你规则运行

import os, sys, time, json, math, statistics, traceback
from datetime import datetime, timedelta
import pytz
import requests
import numpy as np
import cv2
from playwright.sync_api import sync_playwright

# ====== 配置（已填入你的 Token & ChatID & DG 链接） ======
TG_TOKEN = "8134230045:AAH6C_H53R_J2RH98fGTqZFHsjkKALhsTh8"
TG_CHAT_ID = "485427847"
DG_URLS = ["https://dg18.co/wap/", "https://dg18.co/"]
TZ = pytz.timezone("Asia/Kuala_Lumpur")

# 状态文件名（保存在工作区）
STATE_FILE = "dg_state.json"

# ====== Utility ======
def now_ms():
    return int(datetime.now(TZ).timestamp() * 1000)

def fmt_dt(ts_ms=None):
    if ts_ms is None:
        return datetime.now(TZ).strftime("%Y-%m-%d %H:%M:%S")
    return datetime.fromtimestamp(ts_ms/1000, TZ).strftime("%Y-%m-%d %H:%M:%S")

def send_telegram(text):
    try:
        requests.post(
            f"https://api.telegram.org/bot{TG_TOKEN}/sendMessage",
            data={"chat_id": TG_CHAT_ID, "text": text, "parse_mode": "HTML"},
            timeout=20
        )
    except Exception:
        pass

# ====== Image helpers ======
def bytes_to_bgr(img_bytes):
    arr = np.frombuffer(img_bytes, dtype=np.uint8)
    bgr = cv2.imdecode(arr, cv2.IMREAD_COLOR)
    return bgr

def find_red_blue_points(bgr):
    """通过 HSV 阈值 + 霍夫圆检测红/蓝圆点中心"""
    hsv = cv2.cvtColor(bgr, cv2.COLOR_BGR2HSV)
    # 红色范围（两端）
    lower_r1 = np.array([0,60,60]); upper_r1 = np.array([10,255,255])
    lower_r2 = np.array([160,60,60]); upper_r2 = np.array([180,255,255])
    mask_r = cv2.inRange(hsv, lower_r1, upper_r1) | cv2.inRange(hsv, lower_r2, upper_r2)
    # 蓝色
    lower_b = np.array([95,60,60]); upper_b = np.array([135,255,255])
    mask_b = cv2.inRange(hsv, lower_b, upper_b)

    def detect(mask):
        blur = cv2.GaussianBlur(mask, (5,5), 1.2)
        circles = cv2.HoughCircles(blur, cv2.HOUGH_GRADIENT, dp=1.2, minDist=8,
                                   param1=60, param2=10, minRadius=3, maxRadius=20)
        pts = []
        if circles is not None:
            for c in np.round(circles[0]).astype(int):
                x,y,r = int(c[0]), int(c[1]), int(c[2])
                pts.append((x,y))
        return pts

    red_pts = detect(mask_r)
    blue_pts = detect(mask_b)
    return red_pts, blue_pts

def cluster_columns(points, x_tol=None):
    if not points: return []
    pts = sorted(points, key=lambda p: p[0])
    xs = [p[0] for p in pts]
    diffs = [xs[i+1]-xs[i] for i in range(len(xs)-1)] if len(xs)>1 else [16]
    median = int(statistics.median(diffs)) if diffs else 16
    if x_tol is None:
        x_tol = max(8, int(median*0.6))
    cols = [[pts[0]]]
    for p in pts[1:]:
        if abs(p[0] - cols[-1][-1][0]) <= x_tol:
            cols[-1].append(p)
        else:
            cols.append([p])
    # sort each column by y (top->bottom)
    cols = [sorted(c, key=lambda p: p[1]) for c in cols]
    return cols

def longest_run_in_col(col):
    if not col: return 0
    ys = [p[1] for p in col]
    # consider an increment when y increases by > 6 pixels
    runs = 1; best = 1
    for i in range(1,len(ys)):
        if ys[i] - ys[i-1] > 6:
            runs += 1
            if runs > best: best = runs
        else:
            # too close -> consider same cell, ignore
            pass
    return best

# ====== Analyze single table image -> output features ======
def analyze_table_image(img_bgr):
    red_pts, blue_pts = find_red_blue_points(img_bgr)
    marker_count = len(red_pts) + len(blue_pts)

    red_cols = cluster_columns(red_pts)
    blue_cols = cluster_columns(blue_pts)
    all_cols = cluster_columns(red_pts + blue_pts)

    # count columns with >=4 same-color vertical (long4)
    long4_R = sum(1 for c in red_cols if longest_run_in_col(c) >= 4)
    long4_B = sum(1 for c in blue_cols if longest_run_in_col(c) >= 4)
    long8_R = any(longest_run_in_col(c) >= 8 for c in red_cols)
    long8_B = any(longest_run_in_col(c) >= 8 for c in blue_cols)
    long10_R = any(longest_run_in_col(c) >= 10 for c in red_cols)
    long10_B = any(longest_run_in_col(c) >= 10 for c in blue_cols)

    has_long4 = (long4_R + long4_B) > 0
    has_long8 = (long8_R or long8_B)
    has_long10 = (long10_R or long10_B)

    # 多连/连珠：相邻两列同色均>=4
    def has_duolian(color_cols):
        if len(color_cols) < 2: return False
        cols_with_x = []
        for c in color_cols:
            cols_with_x.append((statistics.mean([p[0] for p in c]), c))
        cols_with_x.sort(key=lambda t: t[0])
        for i in range(len(cols_with_x)-1):
            if longest_run_in_col(cols_with_x[i][1]) >= 4 and longest_run_in_col(cols_with_x[i+1][1]) >= 4:
                return True
        return False

    duolian = has_duolian([c for c in red_cols if longest_run_in_col(c) >= 4]) or has_duolian([c for c in blue_cols if longest_run_in_col(c) >= 4])

    # 单跳比例：所有列中最长连<=1 的列占比
    single_jump_ratio = 1.0
    if all_cols:
        single_cols = sum(1 for c in all_cols if longest_run_in_col(c) <= 1)
        single_jump_ratio = single_cols / len(all_cols)

    return {
        "marker_count": marker_count,
        "has_long4": has_long4,
        "has_long8": has_long8,
        "has_long10": has_long10,
        "has_duolian": duolian,
        "single_jump_ratio": single_jump_ratio
    }

# ====== Playwright: enter DG -> capture canvases ======
def solve_slider_if_any(page):
    # best-effort slider attempts (multiple selectors)
    selectors = [
        "div.geetest_slider_button", "div.nc_iconfont.btn_slide", "div.slider", "div#nc_1_n1z",
        "div.yidun_slider", "div.verify-slider", "div.slider-btn", "span.btn_slide", "div.slider_button"
    ]
    for sel in selectors:
        try:
            el = page.query_selector(sel)
            if el:
                box = el.bounding_box()
                if box:
                    x = box["x"] + box["width"]/2
                    y = box["y"] + box["height"]/2
                    page.mouse.move(x,y)
                    page.mouse.down()
                    total = 420
                    step = 40
                    for dx in range(0, total, step):
                        page.mouse.move(x+dx, y, steps=2)
                        time.sleep(0.06)
                    page.mouse.up()
                    time.sleep(1.5)
        except Exception:
            pass

def capture_table_canvases(page):
    # Scroll a bit to ensure elements loaded
    try:
        page.mouse.wheel(0, 400)
        time.sleep(0.3)
    except Exception:
        pass
    images = []
    try:
        canvases = page.query_selector_all("canvas")
        for c in canvases:
            try:
                box = c.bounding_box()
                if not box:
                    continue
                if 120 <= box["width"] <= 420 and 80 <= box["height"] <= 280:
                    img_bytes = c.screenshot()
                    images.append(img_bytes)
            except Exception:
                continue
    except Exception:
        pass
    # Fallback: try find images (some platforms render as <img>)
    if not images:
        imgs = page.query_selector_all("img")
        for im in imgs:
            try:
                box = im.bounding_box()
                if not box:
                    continue
                if 120 <= box["width"] <= 420 and 80 <= box["height"] <= 280:
                    images.append(im.screenshot())
            except Exception:
                continue
    return images

def enter_dg_and_get_canvases():
    canvases = []
    with sync_playwright() as p:
        browser = p.chromium.launch(headless=True, args=["--disable-blink-features=AutomationControlled"])
        context = browser.new_context(viewport={"width":1440,"height":2800})
        page = context.new_page()
        for url in DG_URLS:
            try:
                page.goto(url, timeout=30000)
                # attempt click Free/免费试玩
                clicked = False
                for sel in ["text=Free", "text=FREE", "text=free", "text=免费试玩", "text=免费 试玩"]:
                    try:
                        page.click(sel, timeout=3000)
                        clicked = True
                        break
                    except Exception:
                        pass
                if not clicked:
                    # try buttons with text
                    buttons = page.query_selector_all("button")
                    for b in buttons:
                        try:
                            txt = (b.inner_text() or "").strip()
                            if "Free" in txt or "免费试玩" in txt:
                                b.click(timeout=2000)
                                clicked = True
                                break
                        except Exception:
                            continue

                # wait, handle popup/new page
                for _ in range(20):
                    time.sleep(0.4)
                    if len(context.pages) > 1:
                        page = context.pages[-1]
                        break

                solve_slider_if_any(page)
                time.sleep(1.2)
                page.wait_for_timeout(1100)
                imgs = capture_table_canvases(page)
                if imgs:
                    canvases = imgs
                    browser.close()
                    return canvases
            except Exception:
                # try next url
                continue
        browser.close()
    return canvases

# ====== Overall classification based on all table_stats ======
def classify_overall(table_stats):
    n = len(table_stats)
    long4_tables = sum(1 for t in table_stats if t["has_long4"] and t["single_jump_ratio"] < 0.7)  # 忽略单跳比例高的长连
    long8_tables = sum(1 for t in table_stats if t["has_long8"])
    long10_tables = sum(1 for t in table_stats if t["has_long10"])
    duolian_tables = sum(1 for t in table_stats if t["has_duolian"])
    many_single_jump = sum(1 for t in table_stats if t["single_jump_ratio"] >= 0.7)

    # 超长龙触发型：>=1 超长龙 + 再 >=2 长龙（不含超长龙）
    long8_only = max(0, long8_tables - long10_tables)
    trigger_super = (long10_tables >= 1 and long8_only >= 2)

    # 满盘长连局势型阈值
    cond_full = False
    if n >= 20 and long4_tables >= 8:
        cond_full = True
    elif n >= 10 and long4_tables >= 4:
        cond_full = True

    # 中等胜率（中上）阈值
    cond_mid_up = False
    if ((n >= 20 and long4_tables >= 6) or (n >=10 and long4_tables >= 3)) and ((long8_tables + long10_tables) >= 2) and (duolian_tables >= 1):
        cond_mid_up = True

    # 收割时段判定
    cond_harvest = (long8_tables < 2 and many_single_jump >= max(3, int(0.5*n)))

    detail = {
        "tables": n,
        "long4_tables": long4_tables,
        "long8_tables": long8_tables,
        "long10_tables": long10_tables,
        "duolian_tables": duolian_tables,
        "many_single_jump": many_single_jump,
        "trigger_super": trigger_super,
        "cond_full": cond_full,
        "cond_mid_up": cond_mid_up,
        "cond_harvest": cond_harvest
    }

    # 判定优先级
    if trigger_super or cond_full:
        return "FANGSHUI", detail
    if cond_mid_up:
        return "MID_UP", detail
    if cond_harvest:
        return "HARVEST", detail
    return "MID", detail

# ====== State persistence & ETA estimation ======
def load_state():
    try:
        if os.path.exists(STATE_FILE):
            with open(STATE_FILE, "r", encoding="utf-8") as f:
                return json.load(f)
    except Exception:
        pass
    return {"history": []}

def save_state(st):
    try:
        with open(STATE_FILE, "w", encoding="utf-8") as f:
            json.dump(st, f, ensure_ascii=False, indent=2)
    except Exception:
        pass

def estimate_eta(history, threshold_active):
    # history: list of {ts_ms, metric}
    if len(history) < 3:
        return None, None
    h = history[-6:]
    xs = np.array([(h[i]["ts_ms"] - h[0]["ts_ms"]) / 60000.0 for i in range(len(h))])
    ys = np.array([h[i]["metric"] for i in range(len(h))], dtype=float)
    A = np.vstack([xs, np.ones(len(xs))]).T
    try:
        m, c = np.linalg.lstsq(A, ys, rcond=None)[0]
    except Exception:
        return None, None
    if m >= -1e-6:
        return None, None
    t_cross = (threshold_active - c) / m
    now0 = h[0]["ts_ms"]
    eta_ms = now0 + int(t_cross * 60000)
    mins_left = max(1, int((eta_ms - now_ms())/60000))
    eta_dt = datetime.fromtimestamp(eta_ms/1000, TZ)
    return eta_dt, mins_left

# ====== Main ======
def main():
    run_start = now_ms()
    state = load_state()
    canvases = []
    try:
        canvases = enter_dg_and_get_canvases()
    except Exception as e:
        err = f"Playwright exception: {e}\n{traceback.format_exc()}"
        send_telegram(f"⚠️ [{fmt_dt()}] DG 访问或脚本异常：\n{str(e)[:800]}")
        # write last error file for debugging
        with open("last_error.txt","w",encoding="utf-8") as f:
            f.write(err)
        # still save state and exit
        state["last_run"] = now_ms()
        save_state(state)
        return

    table_stats = []
    for b in canvases:
        try:
            bgr = bytes_to_bgr(b)
            stat = analyze_table_image(bgr)
            table_stats.append(stat)
        except Exception:
            continue

    # If no canvases found, send heartbeat about inability to capture — but still indicate script ran
    if not table_stats:
        send_telegram(f"ℹ️ [{fmt_dt()}] 心跳：脚本正常运行，但未能从 DG 页面捕获到有效桌面图像（canvas/img）。若长期发生，请查看 selectors/页面结构是否变化。")
        state["last_run"] = now_ms()
        save_state(state)
        return

    status, detail = classify_overall(table_stats)

    # update history (use long4_tables as metric)
    history = state.get("history", [])
    history.append({"ts_ms": now_ms(), "metric": detail["long4_tables"]})
    history = history[-48:]  # 保留最近 48 条约4小时
    state["history"] = history

    last_status = state.get("status")
    active_since = state.get("active_since")

    brief = f"总桌:{detail['tables']} | 长连≥4:{detail['long4_tables']} | 长龙≥8:{detail['long8_tables']} | 超长龙≥10:{detail['long10_tables']} | 多连:{detail['duolian_tables']}"

    msg = None
    if status in ("FANGSHUI", "MID_UP"):
        if last_status not in ("FANGSHUI", "MID_UP"):
            # 新开始
            state["active_since"] = now_ms()
            state["active_type"] = status
            eta_dt, mins_left = estimate_eta(history, threshold_active=detail["long4_tables"])
            if eta_dt:
                if status == "FANGSHUI":
                    msg = f"✅ [{fmt_dt()}] 放水时段（提高胜率）已开始\n{brief}\n预计结束时间：{eta_dt.strftime('%H:%M')}（马来西亚时间），预计剩余约 {mins_left} 分钟"
                else:
                    msg = f"⚡ [{fmt_dt()}] 中等胜率（中上）已开始\n{brief}\n预计结束时间：{eta_dt.strftime('%H:%M')}（马来西亚时间），预计剩余约 {mins_left} 分钟"
            else:
                if status == "FANGSHUI":
                    msg = f"✅ [{fmt_dt()}] 放水时段（提高胜率）已开始\n{brief}\n预计结束时间：暂无法可靠预估（趋势未显著下降）"
                else:
                    msg = f"⚡ [{fmt_dt()}] 中等胜率（中上）已开始\n{brief}\n预计结束时间：暂无法可靠预估（趋势未显著下降）"
        else:
            # 仍在活跃中 -> 心跳不重复发开始；但为了让你总有反馈，我们也发简短心跳（可注释掉如不需）
            msg = None  # 不重复发送以避免刷屏
    else:
        # 非活跃：如果上次是活跃，则视为结束 -> 发送结束与持续时长
        if last_status in ("FANGSHUI", "MID_UP") and active_since:
            dur_min = max(1, int((now_ms() - active_since)/60000))
            msg = f"【放水已结束】{fmt_dt()}（马来西亚时间）\n共持续 {dur_min} 分钟。\n{brief}"
            state["active_since"] = None
            state["active_type"] = None
        else:
            # 正常无放水 -> 发送心跳状态（让你知道脚本在跑）
            msg = f"ℹ️ [{fmt_dt()}] 心跳：检测完成，目前无放水迹象。\n{brief}"

    state["status"] = status
    state["last_run"] = now_ms()
    save_state(state)

    if msg:
        send_telegram(msg)

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        try:
            send_telegram(f"⚠️ [{datetime.now(TZ).strftime('%Y-%m-%d %H:%M:%S')}] 未捕获到异常：{str(e)[:800]}")
        except Exception:
            pass
        with open("last_error.txt","w",encoding="utf-8") as f:
            f.write(traceback.format_exc())
PY

      - name: Run monitor.py
        env:
          # 可在仓库 Settings->Secrets->Actions 设置 TG_TOKEN/TG_CHAT_ID 覆盖
          TG_TOKEN: ${{ secrets.TG_TOKEN }}
          TG_CHAT_ID: ${{ secrets.TG_CHAT_ID }}
        run: |
          python monitor.py

      - name: Persist state (if changed) - commit state.json and last_error
        run: |
          if [ -n "$(git status --porcelain)" ]; then
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add -A
            git commit -m "persist state [skip ci]" || true
            git push || true
          fi
